# Web 技術入門 理解度確認テスト - 解答編

## 付録 A コンピュータの基礎

### 問題 1 の解答

**(B) 画像や音声などのバイナリデータを、テキストデータしか扱えない環境（HTTP ヘッダやメールなど）で安全にやり取りするために、テキスト形式に変換する。**

### 問題 2 の解答

**(A) 一方向性**

### 問題 3 の解答

**(D) アプリケーション層**

### 問題 4 の解答

**解答例：**
①Web API のレスポンスには JSON が一般的。理由は、JavaScript で直接パース可能で、XML より軽量で構文がシンプルなため。② 人間が直接編集する設定ファイルには YAML が一般的。理由は、インデントによる階層表現で人間にとって読みやすく、コメントも記述できるため。

### 問題 5 の解答

**解答例：**

```bash
ls | sort -r
```

## 第 1 章 技術の学び方

### 問題 1 の解答

**(D) ハードウェアの性能が向上し、非効率なコードでも動作するようになったこと**

### 問題 2 の解答

**(B) 元々、見た目の指定は全て HTML で行われていたが、保守性を高めるために、構造を HTML、見た目を CSS と役割分担するようになった。**

### 問題 3 の解答

**解答例：**

```
① red
② bold
```

### 問題 4 の解答

**解答例：**
技術を階層として理解することで、新しい技術を学ぶ際に、その技術がどの層に属し、他の層とどう連携するかを把握できる。これにより、技術の位置づけや役割を素早く理解し、効率的に学習を進めることができる。

### 問題 5 の解答

**(B) システムの複雑化と通信量の増加に伴う、HTTP/1.1 の通信の非効率性を改善するため**

## 第 2 章 Web システムの全体像

### 問題 1 の解答

**(B) クライアントサイド、サーバサイド、ネットワーク**

### 問題 2 の解答

**(C) EC サイトで、あるキーワードを入力した際に表示される商品検索結果の一覧**

### 問題 3 の解答

**(C) レンダリングエンジン**

### 問題 4 の解答

**解答例：**
分離型独立プロセス方式では、Web アプリケーションが独立したプロセスとして常駐し続けるため、リクエストごとにプロセスを起動・終了する CGI 方式と比べて、プロセス起動のオーバーヘッドが削減され、レスポンス時間が大幅に短縮される。

### 問題 5 の解答

**(C) CDN（Content Delivery Network）を導入する**

## 第 3 章 WWW の基本要素とその発展

### 問題 1 の解答

**(C) URI、HTTP、HTML**

### 問題 2 の解答

**(B) 文書の論理的な構造と、文字の大きさや色といった視覚的な体裁（見た目）を分離する考え方。**

### 問題 3 の解答

**(C) 問題：見た目をリッチにするための独自タグが乱立し、「構造と体裁の分離」思想が失われた。 → 解決策：CSS**

### 問題 4 の解答

**解答例：**
XHTML は理想的な仕様策定を重視し、厳格な XML ルールを適用したが、既存の HTML との互換性が低く、現場の開発者にとって使いにくかった。一方、HTML5 は現場のニーズを重視し、既存の HTML との互換性を保ちながら実用的な機能を追加したため、広く受け入れられた。

### 問題 5 の解答

**解答例：**

```
① GET /index.html HTTP/1.1
② Host: example.com
```

## 第 4 章 HTTP クライアントと HTTP サーバ

### 問題 1 の解答

**(C) HTTP クライアントと HTTP サーバが、テキストベースのメッセージを送受信する単純な仕組み**

### 問題 2 の解答

**(B) 環境変数（Environment Variables）**

### 問題 3 の解答

**(B) テンプレートエンジン**

### 問題 4 の解答

**解答例：**
問題の原因はサーバ側のレスポンス処理にある。リクエストがサーバに届いているということは、クライアントとサーバ間の通信は正常に行われているが、サーバが適切な HTTP レスポンス（ステータスライン、ヘッダ、ボディ）を返していないため、ブラウザがエラーと判断している。

### 問題 5 の解答

**解答例：**

```
① HTTP/1.1 200 OK
② date
```

## 第 5 章 URL と HTTP

### 問題 1 の解答

**(C) フラグメント (Fragment)**

### 問題 2 の解答

**(C) ステータスライン**

### 問題 3 の解答

**(B) GET はサーバからリソースを取得（参照）するためのもので、リクエストを何度送ってもサーバの状態は変わらないことが期待される。**

### 問題 4 の解答

**解答例：**

- **リクエストターゲット:** `/search?q=test`
- **Host ヘッダの値:** `example.jp`

### 問題 5 の解答

**(D) このエンコーディングはサーバ側でのみ行われ、ブラウザ（クライアント）側ではこの変換に関与しない。**

## 第 6 章 従来型の Web アプリケーション

### 問題 1 の解答

**(B) Post-Redirect-Get (PRG)**

### 問題 2 の解答

**(C) セッション ID**

### 問題 3 の解答

**(D) HttpOnly**

### 問題 4 の解答

**解答例：**
PC とスマートフォンは別々のデバイスであり、それぞれ異なるクッキーを持つため、セッション ID が共有されない。ユーザ認証はセッション ID に基づいて行われるため、スマートフォンでは新しいセッションが開始され、PC でのログイン状態が引き継がれず、再度ログインが必要になる。

### 問題 5 の解答

**解答例：**

```go
http.Redirect(w, r, "/todo", http.StatusSeeOther)
```

## 第 7 章 SPA への進化

### 問題 1 の解答

**(D) Ajax (Asynchronous JavaScript + XML)**

### 問題 2 の解答

**(A) JSON**

### 問題 3 の解答

**(C) 検索エンジンとの相性の悪さ と 初期表示の遅さ**

### 問題 4 の解答

**解答例：**
フラグメント（#以降）はサーバに送信されないため、検索エンジンが異なるページとして認識できず、SEO に不利だった。History API を使うことで、実際の URL を変更しながら画面遷移を行えるため、検索エンジンが各ページを適切に認識し、ユーザーも意味のある URL を見ることができるようになった。

### 問題 5 の解答

**解答例：**

```javascript
① response.json()
② console.log(user.name)
```

## 第 8 章 Web API

### 問題 1 の解答

**(C) 操作の対象となる情報（リソース、名詞）**

### 問題 2 の解答

**(B) POST**

### 問題 3 の解答

**(A) 同一オリジンポリシー (Same-Origin Policy)**

### 問題 4 の解答

**解答例：**
ブラウザは、実際の DELETE リクエストを送信する前に、まず OPTIONS メソッドでプリフライトリクエストを送信し、サーバがクロスオリジンの DELETE リクエストを許可するかを確認する。サーバが適切な CORS ヘッダで許可を返した場合のみ、ブラウザは実際の DELETE リクエストを送信する。

### 問題 5 の解答

**(C) 上記 (A) と (B) の両方の問題が発生する。**

## 第 9 章 サーバプッシュ技術

### 問題 1 の解答

**(B) SSE はサーバからクライアントへの片方向通信、WebSocket は双方向通信を実現する。**

### 問題 2 の解答

**(B) クライアントがまず通常の HTTP リクエストを送信し、ヘッダを使って WebSocket プロトコルへの切り替え（アップグレード）を要求する。**

### 問題 3 の解答

**解答例：**
攻撃者が悪意のあるサイトに、被害者が認証済みの WebSocket サーバへの接続コードを埋め込むことで、被害者のブラウザから意図しない通信が発生する。これを防ぐには、サーバ側でハンドシェイク時に Origin ヘッダを検証し、信頼できるドメインからのリクエストのみを受け入れる必要がある。

### 問題 4 の解答

**(B) Server-sent Events (SSE)**
